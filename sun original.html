<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>


<script>
    console.clear();
    function log(a) {
        // console.log(JSON.stringify(a, " ", 2))
        console.log(a)
    }
    function cake_sun() {

        const Aliases = {
            "x": "l0ckbox",
            "j": "l0ckjaw",
            "q": "l0cket",
            "a": "acct_nt",
            "m": "magnara",
            "W": "l0g_wr1t3r",
            "o": "sn_w_usac",
            "f": "shfflr",
            "N": "CON_TELL",
            "n": "CON_SPEC",
            "D": "DATA_CHECK",
            "g": "sn_w_glock",
            "2": "ez_21",
            "3": "ez_35",
            "4": "ez_40",
            "X": "c001",
            "y": "c002",
            "Y": "c003",
            "C": "cron_bot",
            "c": "char_count",
            "s": "script_slot",
            "S": "public_script",
            "0": "channel_count",
            "k": "k3y",
            "b": "balance",
            "w": "log_writer",
            "t": "transactions",
            "T": "transfer",
            "u": "expose_upgrades",
            "U": "transfer_upgrade",
            "l": "expose_access_log",
            "L": "expose_upgrade_log",
            "z": "w4rn",
            "Z": "w4rn_message",
            "r": "w4rn_er"
        };
        function isAlphaNum(str) {
            if (str === undefined) return false
            for (let i = 0; i < str.length; i++) {
                const code = str[i].charCodeAt(0);
                let r = false
                    || (code >= 48 && code <= 57)   // 0-9
                    || (code >= 65 && code <= 90)   // A-Z
                    || (code >= 97 && code <= 122)  // a-z
                    || "_".includes(str[i])
                if (!r) return false
            }
            return true
        }

        function lex(input) {
            let res = []
            lines = input.split('\n')
            for (let l of lines) {
                let raw = l;
                if (l.includes('//')) {
                    l = l.substring(0, l.indexOf('//'))
                }
                let l2 = l.split(";")
                for (let l3 of l2) {
                    l3 = l3.trim();
                    if (!l3) continue;
                    let tokens = lexLine(l3)
                    res.push({ raw, tokens })
                }
            }
            return res;
        }
        function lexLine(input) {
            const reserved_chars = "=!:;+-^~>[]*"
            const reserved = [
                "->", ...reserved_chars,
            ]
            function compareFromI(a, b, i) {
                return a.substring(i, i + b.length) == b
            }
            let spaces = " \t\r"
            let res = []
            let acc = ""
            mainLoop: for (let i = 0; i < input.length; i++) {
                let c = input[i];
                if (spaces.includes(c)) {
                    while (spaces.includes(c)) {
                        i++;
                        c = input[i];
                        continue;
                    }
                    res.push(" ")
                }

                for (const r of reserved) {
                    if (compareFromI(input, r, i)) {
                        res.push(r)
                        i += r.length - 1;
                        found = true;
                        continue mainLoop
                    }
                }

                if (c == '"') {
                    let str = c
                    do {
                        i++;
                        c = input[i];
                        str += c
                    } while (c != '"')
                    res.push(str)
                    continue
                }

                let str = c
                i++;
                c = input[i];
                while (isAlphaNum(c)) {
                    str += c
                    i++;
                    c = input[i];
                }
                i--
                res.push(str)
            }
            if (res.length > 0 && res[res.length - 1] != ';') res.push(';')
            return res;
        }

        function parse(input) {
            let lines = lex(input)
            // log(tokens)
            let parsed = []
            let errors = []

            let tokens = []
            let cur = tokens[0]
            let curI = 0

            for (const l of lines) {
                tokens = l.tokens
                cur = tokens[0]
                curI = 0

                let script = parseScriptLine()
                if (script.error) {
                    errors.push({ line: l.raw, error: script.error })
                } else {
                    parsed.push(...script.value)
                }
            }
            return { errors, parsed }

            function stackLog(a) {
                // log(a)
            }
            function advance() {
                curI++;
                cur = tokens[curI]
                if (cur === undefined) cur = ";"
                stackLog("Advanced: " + cur)
                return cur
            }
            function next(i) {
                return tokens[curI + i]
            }
            function eof() {
                return curI >= tokens.length
            }
            function save() {
                return { curI, cur }
            }
            function load(a) {
                stackLog(" =========== Load triggered")
                curI = a.curI
                cur = a.cur
            }
            function consume(v) {
                stackLog("consume " + v)
                if (cur != v) {
                    stackLog(`Expected ${v} but got ${cur}`)
                    return error(`Expected ${v} but got ${cur}`)
                }
                stackLog(`consumed`)

                let c = cur
                advance()
                return resp(c)
            }
            function skipSpaces() {
                while (cur == " ") {
                    advance();
                }
            }
            function resp(v) {
                return { value: v }
            }
            function error(e) {
                stackLog("====Throwing and error")
                stackLog(e)
                return { error: e }
            }

            function parseScriptLine() {
                stackLog("parseScriptLine")

                skipSpaces();
                let rules = []
                let errors;
                let last_error = ""
                while (!eof()) {

                    while (cur == ";") advance();
                    if (eof()) return resp(rules);

                    let r = parseRule()
                    if (r.error) return r;
                    if (r.value) rules.push(r.value)
                }
                if (last_error) return last_error;
                // if (rules.length == 0) return error("Expected an action but got " + cur)
                return resp(rules)
            }

            function parseRule() {
                stackLog("parseRule")

                skipSpaces();
                let res = {}
                let __resExample = {
                    filters: [],
                    actions: [],
                    pp: false,
                    return: false,
                }
                if (cur == ">") {
                    res.return = true;
                    advance()
                    skipSpaces();
                    let t = consume(";")
                    if (t.error) return t;
                    return resp(res)
                }
                if (cur == "pp") {
                    advance();
                    res.pp = true
                    let s = consume(" ");
                    if (s.error) return s;
                    skipSpaces();
                }

                if (cur == "alias") {
                    let alias = parseAlias()
                    if (alias.error) return alias;
                    res.alias = alias.value
                    return resp(res)
                }

                let filters = parseFilters()
                if (filters.error) return filters;
                res.filters = filters.value
                skipSpaces();

                if (cur == ";") {
                    advance();
                    // if (res.actions.length == 0) delete res.actions
                    return resp(res)
                }

                skipSpaces();

                if (cur == '->') {
                    advance();

                    let actions = parseActions()
                    if (actions.error) return actions;
                    res.actions = actions.value;
                    skipSpaces();

                    t = consume(";");
                    if (t.error) return t;
                }

                // if (res.actions.length == 0) delete res.actions

                return resp(res)
            }

            function parseActions() {
                stackLog("parseActions")
                let actions = []

                while (true) {
                    skipSpaces();
                    if (cur == ';') return resp(actions);

                    let a = parseAction()
                    if (a.error) return a

                    actions.push(a.value)
                }
                if (actions.length == 0) return error("Expected an action but got " + cur)
                return resp(actions)
            }

            function parseAction() {
                stackLog("parseAction")

                skipSpaces();
                let res = {}

                if (!isAlphaNum(cur)) return error("Property names must be alphanumeric. You provided " + cur)
                res.k = cur
                advance();
                skipSpaces()

                if (isAlphaNum(cur) || cur == ';') {
                    res.v = true
                    return resp(res)
                } else if (cur == '=') {
                    advance();
                    skipSpaces()

                    let v = parseValueType()
                    if (v.error) return v

                    res.v = v.value;
                    // if (!isAlphaNum(cur.replace(/"/gm, ""))) return error("Property names must be alphanumeric. You provided " + cur)
                    // res.v = cur

                    advance();
                    return resp(res)
                } else {
                    return error("Expected = or ; or space but got " + cur)
                }
            }

            function parseAlias() {
                stackLog("parseAlias")

                let res = {}
                let t = consume("alias");
                if (t.error) return t;

                t = consume(" ");
                if (t.error) return t;
                skipSpaces();

                if (cur.length != 1) return error("Aliases can only be single characters. Can't use " + cur)
                res.k = cur
                advance();
                skipSpaces();

                t = consume("=");
                if (t.error) return t;
                skipSpaces();

                if (!isAlphaNum(cur)) return error("Upgrade names must be alphanumeric. You provided" + cur)
                res.v = cur
                advance();
                skipSpaces();

                t = consume(";");
                if (t.error) return t;

                return resp(res);
            }

            function parseFilters() {
                stackLog("parseFilters")
                skipSpaces();

                let filters = []

                //There can be only one sun filter and it comes at the start
                let s = save();
                let neg = parseNegation()
                let sun = parseSUN()
                if (sun.error) {
                    load(s)
                } else {
                    if (neg.value) sun.value.negative = neg.value
                    filters.push(sun.value)
                }

                skipSpaces()

                while (!(cur == "->" || cur == ";" || eof())) {
                    let neg = parseNegation()
                    let lun = parseLUN()
                    if (lun.error && sun.error) return sun;
                    if (lun.error) return lun;
                    if (neg.value) lun.value.negative = neg.value

                    filters.push(lun.value)
                    skipSpaces()
                    if (sun.error) delete sun.error
                }
                // advance()

                return resp(filters)
            }

            function parseNegation() {
                skipSpaces();
                if (cur == "!") {
                    advance();
                    return resp(true)
                } else {
                    return resp(false)
                }
            }



            function parseSUN() {
                stackLog("parseSUN")


                let r = {
                    // filter: "sun",
                    loaded: undefined,
                    ready: undefined,
                    alias: undefined,
                    tier: undefined,
                    rarity: undefined,
                    value: undefined,
                }

                // advance()
                if (cur == "+") {
                    r.loaded = true
                    advance()
                } else if (cur == "-") {
                    r.loaded = false
                    advance()
                }

                if (cur == "^") {
                    r.ready = true
                    advance()
                } else if (cur == "~") {
                    r.ready = false
                    advance()
                }

                if (!isAlphaNum(cur) && cur != "*") return error("SUN Rule Error. Expected an alias char, but got " + cur)

                switch (cur.length) {
                    case 3: {
                        r.alias = cur[0]
                        r.tier = cur[1]
                        r.rarity = cur[2]
                        advance()
                    } break;
                    case 2: {
                        r.alias = cur[0]
                        r.tier = cur[1]
                        advance()
                        if (cur.length == 1 && (isAlphaNum(cur) || cur == "*")) {
                            r.rarity = cur;
                            advance()
                        }
                    } break;
                    case 1: {
                        r.alias = cur[0]
                        advance()
                        if (cur.length == 1 && (isAlphaNum(cur) || cur == "*")) {
                            r.tier = cur;
                            advance()
                        }
                        if (cur.length == 1 && (isAlphaNum(cur) || cur == "*")) {
                            r.rarity = cur;
                            advance()
                        }

                    } break;
                        break;
                    default: return error("SUN Rule Error. Expected an alias char, but got " + cur);
                }

                if (r.tier && r.tier != "*") r.tier = Number(r.tier)
                if (r.rarity && r.rarity != "*") r.rarity = Number(r.rarity)


                if (cur == "[") {
                    consume("[")

                    let v = parseValue()
                    if (v.error) return v;

                    if (v.value && v.value.type == "value") {
                        r.value = v.value.value;
                    } else {
                        r.value = v.value;
                    }

                    let end = consume("]")
                    if (end.error) return end;
                }
                if (cur != ' ' && cur != ';' && cur != '->') {
                    return error("SUN Rule Error. Expected -> or ; or space but got " + cur);
                }
                advance()

                for (const k in r) {
                    //Shorter final object
                    if (r[k] == "*") delete r[k]
                    if (r[k] == undefined) delete r[k]
                }

                return resp(r);
            }

            function parseLUN() {
                stackLog("parseLUN")

                let res = { /*filter: "lun"*/ }
                if (!isAlphaNum(cur)) {
                    return error("Property name must be alphanumeric. Got " + cur)
                }
                let name = cur;
                advance()
                skipSpaces()
                if (cur == '=') {
                    let c = consume("=")
                    if (c.error) return c;
                    skipSpaces()
                    let v = parseValue()
                    if (v.error) return v

                    if (v.value && v.value.type == "value") {
                        res[name] = v.value.value;
                    } else {
                        res[name] = v.value;
                    }

                    return resp(res)
                } else if ([" ", ";", "->", "!"].includes(cur)) {
                    skipSpaces()
                    let v = true
                    res[name] = true;

                    return resp(res)
                } else {
                    return error("Failed to parse LUN. Expected = or ; or -> or ! or space. Got " + cur)
                }
            }

            function parseValue() {
                stackLog("parseValue")

                if (next(1) == ":") {
                    let r = parseRange()
                    if (r.error) return r;
                    if (r.value.min == undefined && r.value.max == undefined) return resp(undefined)
                    return resp({ type: "range", min: r.value.min, max: r.value.max })
                } else {
                    let v = parseValueType()
                    if (v.error) return v;
                    if (v.value == undefined) return resp(undefined)
                    return resp({ type: "value", value: v.value })
                }
            }

            function parseValueType() {
                stackLog("parseValueType")
                let v = cur;
                if (!isNaN(Number(v))) {
                    advance();
                    return resp(Number(v))
                }
                if (v[0] == '"' && v[v.length - 1] == '"') {
                    v = v.replace(/\"/gm, "")
                    advance();
                    return resp(v)
                }
                if (isAlphaNum(v)) {
                    if (v == "true") v = true;
                    if (v == "false") v = false;
                    // Don't do this because it's an edge case. We eill check for it later
                    // if (v == "undefined") v = undefined;

                    advance();
                    return resp(v)
                }
                if (v == "*") {
                    v = undefined
                    advance();
                    return resp(v)
                }

                return error("Failed to parse value " + v)
            }

            function parseRange() {
                let min = parseValueType()
                if (min.error) return min;

                let m = consume(":")
                if (m.error) return m;

                let max = parseValueType()
                if (max.error) return max;

                return resp({ min: min.value, max: max.value })
            }
        }

        function runTests() {
            const stressTest = compile(`
+^c12[1000:*] a=1 !b=a -> a=1 b="2" c="3 3" d=true e f_f = 123 g=undefined; +*; +c; -c; +^T; +~T; c1;
c10; c*0; *1; **0; c1[1000]; c[*:1000]; c[1000:*]; c[1000:*] good=true; *; **; ***; ***[*]; ***[*:*];
alias c = char_count; c[1400:*] -> keep=true price=1BGC;>; c[1000:*] -> sell=true price=100MGC;>;
c -> cull=true;>; pp -c keep=true !_best=10 -> keep=undefined sell=true; pp c _best=1 -> the_best=true;
c->good=true; alias N = char_count; N[1000]; alias N = script_slot; N[4]; a=1; b="Hello World";
c=Hello_World; d=undefined; e=true; f=false; c[1000:1200]; c[*]; c; c[1000:*]; *[1]; c -> good=true;
c -> good=true veryGood=true; c[*:1000] -> bad=true; s[*:2];; c; c -> good=true cool=true; c -> good=true;
c -> good; name="char_count_v1" rarity=1 -> good=true; tier=3 rarity=1:* -> good=true; good=undefined -> bad=true;
c good=true -> cool=true; c good -> cool=true; c bad=false     -> cool=true; c bad=undefined -> cool=true;
c !bad -> cool=true; c _best=10   -> cool=true; c _worst=10  -> cool=false; c !_best=10  -> cool=false;
c !_worst=10 -> cool=true; c[1400:*] -> keep=true price=1BGC; >; c[1000:*] -> sell=true price=100MGC; >;
c -> cull=true; >; S[4] -> keep=true;>; c[1400:*] -> keep=true price=1BGC;>; c[1000:*] -> sell=true price=100MGC;
>; c -> cull=true;>; pp * !keep !sell !cull -> anomaly=true;`);

            let Expected = { "stages": [[{ "filters": [{ "loaded": true, "ready": true, "alias": "c", "tier": 1, "rarity": 2, "value": { "type": "range", "min": 1000 } }, { "k": "a", "v": { "type": "value", "value": 1 } }, { "k": "b", "v": { "type": "value", "value": "a" }, "negative": true }], "actions": [{ "k": "a", "v": 1 }, { "k": "b", "v": "2" }, { "k": "c", "v": "3 3" }, { "k": "d", "v": true }, { "k": "e", "v": true }, { "k": "f_f", "v": 123 }, { "k": "g" }] }, { "filters": [{ "loaded": true }] }, { "filters": [{ "loaded": true, "alias": "c" }] }, { "filters": [{ "loaded": false, "alias": "c" }] }, { "filters": [{ "loaded": true, "ready": true, "alias": "T" }] }, { "filters": [{ "loaded": true, "ready": false, "alias": "T" }] }, { "filters": [{ "alias": "c", "tier": 1 }] }, { "filters": [{ "alias": "c", "tier": 1, "rarity": 0 }] }, { "filters": [{ "alias": "c", "rarity": 0 }] }, { "filters": [{ "tier": 1 }] }, { "filters": [{ "rarity": 0 }] }, { "filters": [{ "alias": "c", "tier": 1, "value": { "type": "value", "value": 1000 } }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "max": 1000 } }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000 } }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000 } }, { "k": "good", "v": { "type": "value", "value": true } }] }, { "filters": [{}] }, { "filters": [{}] }, { "filters": [{}] }, { "filters": [{}] }, { "filters": [{}] }, { "alias": { "k": "c", "v": "char_count" } }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1400 } }], "actions": [{ "k": "keep", "v": true }, { "k": "price", "v": "1BGC" }] }, { "return": true }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000 } }], "actions": [{ "k": "sell", "v": true }, { "k": "price", "v": "100MGC" }] }, { "return": true }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "cull", "v": true }] }, { "return": true }, { "filters": [{ "alias": "c" }, { "k": "good", "v": { "type": "value", "value": true } }] }, { "alias": { "k": "N", "v": "char_count" } }, { "filters": [{ "alias": "N", "value": { "type": "value", "value": 1000 } }] }, { "alias": { "k": "N", "v": "script_slot" } }, { "filters": [{ "alias": "N", "value": { "type": "value", "value": 4 } }] }, { "filters": [{ "k": "a", "v": { "type": "value", "value": 1 } }] }, { "filters": [{ "k": "b", "v": { "type": "value", "value": "Hello World" } }] }, { "filters": [{ "k": "c", "v": { "type": "value", "value": "Hello_World" } }] }, { "filters": [{ "k": "d" }] }, { "filters": [{ "k": "e", "v": { "type": "value", "value": true } }] }, { "filters": [{ "k": "f", "v": { "type": "value", "value": false } }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000, "max": 1200 } }] }, { "filters": [{ "alias": "c" }] }, { "filters": [{ "alias": "c" }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000 } }] }, { "filters": [{ "value": { "type": "value", "value": 1 } }] }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "good", "v": true }] }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "good", "v": true }, { "k": "veryGood", "v": true }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "max": 1000 } }], "actions": [{ "k": "bad", "v": true }] }, { "filters": [{ "alias": "s", "value": { "type": "range", "max": 2 } }] }, { "filters": [{ "alias": "c" }] }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "good", "v": true }, { "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "good", "v": true }] }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "good", "v": true }] }, { "filters": [{ "k": "name", "v": { "type": "value", "value": "char_count_v1" } }, { "k": "rarity", "v": { "type": "value", "value": 1 } }], "actions": [{ "k": "good", "v": true }] }, { "filters": [{ "k": "tier", "v": { "type": "value", "value": 3 } }, { "k": "rarity", "v": { "type": "range", "min": 1 } }], "actions": [{ "k": "good", "v": true }] }, { "filters": [{ "k": "good" }], "actions": [{ "k": "bad", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "good", "v": { "type": "value", "value": true } }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "good", "v": true }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "bad", "v": { "type": "value", "value": false } }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "bad" }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "bad", "v": true, "negative": true }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "_best", "v": { "type": "value", "value": 10 } }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c" }, { "k": "_worst", "v": { "type": "value", "value": 10 } }], "actions": [{ "k": "cool", "v": false }] }, { "filters": [{ "alias": "c" }, { "k": "_best", "v": { "type": "value", "value": 10 }, "negative": true }], "actions": [{ "k": "cool", "v": false }] }, { "filters": [{ "alias": "c" }, { "k": "_worst", "v": { "type": "value", "value": 10 }, "negative": true }], "actions": [{ "k": "cool", "v": true }] }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1400 } }], "actions": [{ "k": "keep", "v": true }, { "k": "price", "v": "1BGC" }] }, { "return": true }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000 } }], "actions": [{ "k": "sell", "v": true }, { "k": "price", "v": "100MGC" }] }, { "return": true }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "cull", "v": true }] }, { "return": true }, { "filters": [{ "alias": "S", "value": { "type": "value", "value": 4 } }], "actions": [{ "k": "keep", "v": true }] }, { "return": true }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1400 } }], "actions": [{ "k": "keep", "v": true }, { "k": "price", "v": "1BGC" }] }, { "return": true }, { "filters": [{ "alias": "c", "value": { "type": "range", "min": 1000 } }], "actions": [{ "k": "sell", "v": true }, { "k": "price", "v": "100MGC" }] }, { "return": true }, { "filters": [{ "alias": "c" }], "actions": [{ "k": "cull", "v": true }] }, { "return": true }], [{ "pp": true, "filters": [{ "loaded": false, "alias": "c" }, { "k": "keep", "v": { "type": "value", "value": true } }, { "k": "_best", "v": { "type": "value", "value": 10 }, "negative": true }], "actions": [{ "k": "keep" }, { "k": "sell", "v": true }] }, { "pp": true, "filters": [{ "alias": "c" }, { "k": "_best", "v": { "type": "value", "value": 1 } }], "actions": [{ "k": "the_best", "v": true }] }, { "pp": true, "filters": [{}, { "k": "keep", "v": true, "negative": true }, { "k": "sell", "v": true, "negative": true }, { "k": "cull", "v": true, "negative": true }], "actions": [{ "k": "anomaly", "v": true }] }]] }

            return JSON.stringify(Expected) === JSON.stringify(Expected);
        }

        function compile(input) {
            let ast = parse(input)
            if (ast.errors.length > 0) throw ast.errors
            let p = ast.parsed.filter(a => !a.pp)
            let pp = ast.parsed.filter(a => a.pp)
            return {
                stages: [
                    p, pp,
                ]
            }
        }

        function filter(upgrades, compiled) {

            function shortUpName(name) {
                return name.replaceAll("_v1", "").replaceAll("_v2", "").replaceAll("_v3", "").replaceAll("_v4", "").replaceAll("_V1", "").replaceAll("_V2", "").replaceAll("_V3", "").replaceAll("_V4", "")
            }

            function getUpgradeValue(u) {
                let n = shortUpName(u.name)
                let dict = {
                    "k3y": u.k3y,
                    "CON_SPEC": u.p2_len,
                    "acct_nt": u.acct_nt_min,
                    "sn_w_glock": u.expire_secs,
                    "sn_w_usac": u.salt_digits,
                    "magnara": u.magnara_len,
                    "shfflr": u.digits,
                    "l0g_wr1t3r": u.loc_count,
                    "w4rn_message": u.cooldown,
                    "DATA_CHECK": u.acc_mod,
                    "l0cket": u.count,
                    "l0ckbox": u.count,
                    "l0ckjaw": u.count,
                    "balance": u.cooldown,
                    "expose_access_log": u.count,
                    "expose_upgrade_log": u.count,
                    "expose_upgrades": u.cooldown,
                    "log_writer": u.cooldown,
                    "transactions": u.count,
                    "transfer_upgrade": u.count,
                    "transfer": u.amount,
                    "channel_count": u.count,
                    "char_count": u.chars,
                    "public_script": u.slots,
                    "script_slot": u.slots,
                    "cron_bot": u.cooldown,
                }
                return dict[n]
            }
            function getUpgradeQuality(u) {
                let n = shortUpName(u.name)
                if (n == "k3y") {
                    if (u.rarity == 0) return 3;
                    if (u.rarity == 1) return 2;
                    if (u.rarity >= 2) return 1;
                }
                let dict = {
                    "CON_SPEC": u.p2_len,
                    "acct_nt": u.acct_nt_min,
                    "sn_w_usac": u.salt_digits,
                    "magnara": u.magnara_len,
                    "shfflr": u.digits,
                    "l0g_wr1t3r": u.loc_count,
                    "DATA_CHECK": u.acc_mod,
                    "l0cket": u.count,
                    "l0ckbox": u.count,
                    "l0ckjaw": u.count,
                    "expose_access_log": u.count,
                    "expose_upgrade_log": u.count,
                    "transactions": u.count,
                    "transfer_upgrade": u.count,
                    "transfer": u.amount,
                    "channel_count": u.count,
                    "char_count": u.chars,
                    "public_script": u.slots,
                    "script_slot": u.slots,
                    "sn_w_glock": u.expire_secs,
                    "w4rn_message": -u.cooldown,
                    "balance": -u.cooldown,
                    "expose_upgrades": -u.cooldown,
                    "log_writer": -u.cooldown,
                    "cron_bot": -u.cooldown,
                }
                if (n in dict) return dict[n]
                return 1;
            }
            function getCD(u) {
                if (!u.last_time) return -1
                return u.cooldown * 1000 - (new Date() - u.last_time)
            }
            function upReady(u) {
                return getCD(u) <= 0
            }

            function inRangeOrValue(val, range) {
                if (range && range.type == "range") {
                    let match = true;
                    if (val == undefined) return false
                    if (range.min != undefined && val < range.min) match = false;
                    if (range.max != undefined && val > range.max) match = false;
                    return match;
                } else {
                    if (range == "undefined") range = undefined
                    return val === range
                }
            }

            function filterOneUpgrade(u, filters) {
                for (const f of filters) {
                    let negative = f.negative == true;
                    if (f.alias != undefined && ((aliases[f.alias] != shortUpName(u.name)) ^ negative)) return false
                    if (f.ready != undefined && ((f.ready != upReady(u)) ^ negative)) return false;
                    if (f.value != undefined && ((!inRangeOrValue(getUpgradeValue(u), f.value)) ^ negative)) return false;

                    for (const k in f) {
                        if (["_best", "_worst", "alias", "ready", "value", "pp"].includes(k)) continue;
                        const v = f[k];
                        if (v != undefined && ((!inRangeOrValue(u[k], v)) ^ negative)) return false;
                    }
                }
                return true;
            }

            function compareQuality(a, b) {
                let an = shortUpName(a.name)
                let bn = shortUpName(b.name)
                let aq = getUpgradeQuality(a)
                let bq = getUpgradeQuality(b)
                if (an != bn) return 0;
                if (an == 'k3y' && a.k3y != b.k3y) {
                    return 0;
                }
                return bq - aq;
            }

            function filterBest(ups, count, worst, negative) {
                ups.sort(compareQuality)
                if (worst) ups.reverse()
                if(!negative) return ups.slice(0, count)
                if(negative) return ups.slice(count); 
            }

            function performActions(up, actions) {
                for (const a of actions) {
                    up[a.k] = a.v
                    if (a.v == "undefined") delete up[a.k]
                }
            }

            let aliases = { ...Aliases };
            let triggered = false
            for (const stage of compiled.stages) {
                for (const rule of stage) {
                    console.log(rule);

                    if (rule.return && triggered) {
                        break;
                    }
                    if (rule.alias) {
                        aliases[rule.alias.k] = rule.alias.v
                        continue
                    }
                    let ups = []
                    for (const u of upgrades) {
                        if (filterOneUpgrade(u, rule.filters)) {
                            ups.push(u)
                            triggered = true;
                        }
                    }
                    if (rule.filters.find(a => a._best)) {
                        let f = rule.filters.find(a => a._best)
                        ups = filterBest(ups, f._best, false, f.negative)
                    } else if (rule.filters.find(a => a._worst)) {
                        let f = rule.filters.find(a => a._worst)
                        ups = filterBest(ups, f._worst, false, f.negative)
                    }
                    for (const u of ups) {
                        performActions(u, rule.actions)
                    }

                }
            }
        }

        return { compile, filter, runTests }
    }

    const SUN = cake_sun();



    log(SUN.runTests())


    const CharCountFilter = SUN.compile(`
        alias c = char_count
        c[1400:*] -> keep=true price=1BGC;>   // Keep all char_counts with 1400+ chars 
        c[1000:*] -> sell=true price=100MGC;> // Sell all char_counts with 1000+ chars 
        c         -> cull=true;>              // Destroy all other char_counts
        
        // pp stands for post process. Triggers after all other filters
        // Sell all unloaded char_counts except best 10 
        pp c keep=true !_best=3 -> keep=undefined sell=true
        pp c _best=1 -> the_best=true //Find the best char_counts and mark it
        pp * !keep !sell !cull -> anomaly=true
    `)

    // Sample upgrades array
    const upgrades =[
        { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1763, "sn": "68c5fa131be6dd10929e769e", "description": "char_count adds space for additional characters in every script.", "i": 0 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1534, "sn": "68e00e031be6dd48dc9f4ec9", "description": "char_count adds space for additional characters in every script.", "i": 1 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1531, "sn": "68d8d75d1be6dd38b88e6623", "description": "char_count adds space for additional characters in every script.", "i": 2 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1527, "sn": "691a397d1be6dd04a3b24940", "description": "char_count adds space for additional characters in every script.", "i": 3 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1520, "sn": "68e02bc51be6dd5ba0d2a3a5", "description": "char_count adds space for additional characters in every script.", "i": 4 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1506, "sn": "68c844f21be6dd7630187c48", "description": "char_count adds space for additional characters in every script.", "i": 5 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1504, "sn": "6915ccc01be6dd399344fbdf", "description": "char_count adds space for additional characters in every script.", "i": 6 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1493, "sn": "68bd6fd21be6dd2b10fcc2a7", "description": "char_count adds space for additional characters in every script.", "i": 7 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1492, "sn": "691d9ec81be6dd429e206937", "description": "char_count adds space for additional characters in every script.", "i": 8 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1491, "sn": "6915fa741be6dd7ae210714d", "description": "char_count adds space for additional characters in every script.", "i": 9 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1487, "sn": "68dd6d941be6dd5e587b7945", "description": "char_count adds space for additional characters in every script.", "i": 10 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1483, "sn": "68bac6f51be6dd1ba4755f39", "description": "char_count adds space for additional characters in every script.", "i": 11 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1469, "sn": "68bc65181be6dd3701333a2d", "description": "char_count adds space for additional characters in every script.", "i": 12 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1469, "sn": "691949f61be6dd485e85458a", "description": "char_count adds space for additional characters in every script.", "i": 13 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1460, "sn": "690b90b21be6dd53093b3d57", "description": "char_count adds space for additional characters in every script.", "i": 14 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1456, "sn": "68d431361be6dd2db71be885", "description": "char_count adds space for additional characters in every script.", "i": 15 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1451, "sn": "68dcc6021be6dd5fc9488924", "description": "char_count adds space for additional characters in every script.", "i": 16 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1450, "sn": "6911d8ba1be6dd0cc402750f", "description": "char_count adds space for additional characters in every script.", "i": 17 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1445, "sn": "691a49e61be6dd45385a4a6a", "description": "char_count adds space for additional characters in every script.", "i": 18 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1442, "sn": "691cd0891be6dd3b753758d5", "description": "char_count adds space for additional characters in every script.", "i": 19 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1437, "sn": "68e039611be6dd3a40142cb1", "description": "char_count adds space for additional characters in every script.", "i": 20 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1430, "sn": "68c51a791be6dd7d603a5058", "description": "char_count adds space for additional characters in every script.", "i": 21 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1430, "sn": "68cece9d1be6dd2a21d5fea9", "description": "char_count adds space for additional characters in every script.", "i": 22 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1426, "sn": "690736ed1be6dd5aa54f450c", "description": "char_count adds space for additional characters in every script.", "i": 23 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1423, "sn": "68c6c6ad1be6dd7388fe2f6d", "description": "char_count adds space for additional characters inevery script.", "i": 24 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1423, "sn": "68dd52291be6dd1a0b12e6cb", "description": "char_count adds space for additional characters in every script.", "i": 25 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1422, "sn": "68bcdef91be6dd5e925d0c93", "description": "char_count adds space for additional characters in every script.", "i": 26 }, { "rarity": 3, "name": "char_count_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "chars": 1422, "sn": "6905ebc11be6dd5233fce6e1", "description": "char_count adds space for additional characters in every script.", "i": 27 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "68c83ed81be6dd1f1b3512c3", "description": "public_script_slot allows you to mark scripts as public.", "i": 28 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "68b660c91be6dd401c5ae4b9", "description": "public_script_slot allows you to mark scripts as public.", "i": 29 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "691730c61be6dd6a178d7399", "description": "public_script_slot allows you to mark scripts as public.", "i": 30 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "691868421be6dd671e5dd88d", "description": "public_script_slot allows you to mark scripts as public.", "i": 31 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "6915b8991be6dd78488815cc", "description": "public_script_slot allows you to mark scripts as public.", "i": 32 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68d13c2d1be6dd094b35694a", "description": "public_script_slot allows you to mark scripts as public.", "i": 33 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68b90b0d1be6dd5d233c5a55", "description": "public_script_slot allows you to mark scripts as public.", "i": 34 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68c8bcb61be6dd443f61c291", "description": "public_script_slot allows you to mark scripts as public.", "i": 35 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68c1c33e1be6dd04b536c21a", "description": "public_script_slot allows you to mark scripts as public.", "i": 36 }, { "rarity": 3, "name": "public_script_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68bd6ea71be6dd02ec452bc2", "description": "public_script_slot allows you to mark scripts as public.", "i": 37 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "68b744201be6dd6330c08995", "description": "script_slot allows you to increase your script slots.", "i": 38 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "68e022dd1be6dd234b8601f2", "description": "script_slot allows you to increase your script slots.", "i": 39 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 4, "sn": "691bfc6d1be6dd4678d146bd", "description": "script_slot allows you to increase your script slots.", "i": 40 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68ae55191be6dd71fb861bf7", "description": "script_slot allows you to increase your script slots.", "i": 41 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68c77ea91be6dd7db008d3ab", "description": "script_slot allows you to increase your script slots.", "i": 42 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68c4bd321be6dd51c35dcb3d", "description": "script_slot allows you to increase your script slots.", "i": 43 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68b78f991be6dd45149e979e", "description": "script_slot allows you to increase your script slots.", "i": 44 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68cd867e1be6dd0f2076338a", "description": "script_slot allows you to increase your script slots.", "i": 45 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68c82dbd1be6dd4dcd9da087", "description": "script_slot allows you to increase your script slots.", "i": 46 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68e9cb0c1be6dd374572a04a", "description": "script_slot allows you to increase your script slots.", "i": 47 }, { "rarity": 3, "name": "script_slot_v2", "type": "script_space", "up_class": 0, "tier": 2, "loaded": true, "slots": 3, "sn": "68b0f6b11be6dd6360a06488", "description": "script_slot allows youto increase your script slots.", "i": 48 }, { "rarity": 3, "name": "cron_bot_v2", "type": "bot_brain", "up_class": 0, "tier": 2, "loaded": true, "cooldown": 386, "cost": 40079, "retries": 2, "last_run": "2025-11-27T17:25:44.232Z", "fails": 0, "sn": "691b7da21be6dd1d2840c4aa", "description": "bot_brain upgrades will call your bot_brain script based on the upgrade's cooldown interval, allowing you to automate your user.", "i": 49 }, { "rarity": 1, "name": "l0ckjaw", "type": "lock", "up_class": -1, "tier": 3, "loaded": true, "count": 37, "expire_secs": 300, "sn": "68da43a96ef487382e3319ff", "description": "The l0ckjaw from nuutec is like a guard dog for your secrets. Hopefully no one brings a steak.", "i": 50 }, { "rarity": 2, "name": "sn_w_usac", "type": "lock", "up_class": -1, "tier": 3, "loaded": true, "salt_digits": 1, "sn": "674d8b461be6dd1d860885e3", "description": "0110111101101101011011100110111101101101011011100110111101101101", "i": 51 }, { "rarity": 2, "name": "shfflr", "type": "lock", "up_class": -1, "tier": 3, "loaded": true, "up_count_min": 4, "up_count_max": 59, "name_count": 3, "rarity_count": 2, "digits": 4, "sn": "68ad2a481be6dd2b08e4a617", "description": "that? i did was put right where now here. it just", "i": 52 }, { "rarity": 3, "name": "acct_nt", "type": "lock", "up_class": -1, "tier": 2, "loaded": true, "acct_nt_min": 12, "sn": "68cb251d1be6dd2ee61e3d1b", "description": "Balancing a transaction roster is an important task for any enterprising businessperson.", "i": 53 }, { "rarity": 3, "name": "sn_w_glock", "type": "lock", "up_class": -1, "tier": 2, "loaded": true, "max_glock_amnt": 59846206612, "expire_secs": 91, "sn": "68c4bf111be6dd140384a33d", "description": "Hope you thought about your acct before you went compromising unknown systems.", "i": 54 }, { "rarity": 3, "name": "l0ckbox", "type": "lock", "up_class": -1, "tier": 2, "loaded": true, "count": 27, "sn": "68c561b91be6dd3aa4e75be6", "description": "The nuutec l0ckbox secures you and your cuddlyone from prying eyes", "i": 55 }, { "rarity": 3, "name": "magnara", "type": "lock", "up_class": -1, "tier": 2, "loaded": true, "magnara_len": 7, "sn": "68c4a3691be6dd4c3ea3bb1a", "description": "mi ton sreu ohw tish skowr", "i": 56 }, { "rarity": 1, "name": "l0g_wr1t3r", "type": "lock", "up_class": -1, "tier": 3, "loaded": true, "loc_count": 1, "sn": "68f0eef21be6dd1d9db22bb3", "description": "g3t g00d", "i": 57 }]

 

    log(SUN.filter(upgrades, CharCountFilter))

    console.table(upgrades)

    // console.log(upgrades.filter(a=>a.FOUND));
    

</script>

</html>